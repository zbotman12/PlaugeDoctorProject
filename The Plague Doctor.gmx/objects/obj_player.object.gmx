<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_idle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-5</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>spr_player_mask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize Variables

//Buttons
right = false;
left = false;
rightAndLeftPressed = false;
runningRight = false;
runningLeft = false;
grounded = false;
hidden = false;
grabbing = false;
runButton = false;
climbing = false;
stairs = false;
click = false;
lastDir = 0;
gamepadHor = false;
gamepadA = false;
gamepadX = false;
gamepadY = false;
gamepadB = false;
gamepadStart = false;
gamepadLT = false;
gamepadVert = false;
jump = false;
gamepadDpadUpPressed = false;
gamepadDpadDownPressed = false;
gamepadDpadLeftPressed = false;
gamepadDpadRightPressed = false;
gamepadDpadUp = false;
gamepadDpadDown = false;
gamepadDpadLeft = false;
gamepadDpadRight = false;
//kinematics

maxWalkingSpeed = 6;
WalkingSpeed = 6;
slopeScanValue = -4;

maxRunningSpeed = 10;
RunningSpeed = 10;
RunningSlopeScanValue = -4;

maxCrouchingSpeed = 5;
CrouchingSpeed = 3;
CrouchingSlopeScanValue = -8;

maxSlideSpeed = 4;
slideSpeed = 6;
slideTime = 8;
slideCounter = slideTime;
sliding = false;

airSpeed = 6;
maxAirSpeed = 6;

baseJumpSpeed = -3;

ladderSpeed = 6;
temp = 0;

fatiqued = false;

backfootPointX = 0;
backfootPointY = 0;
rayHitPointX = 0;
rayHitPointY = 0;

//spritestuff
image_speed = 2;
image_index = 0;

//doors
PressWPrompt = false;
lastRoom = room;
lastRoomX = 0;
lastRoomY = 0;
start_x = xstart;
start_y = ystart;
door = noone;
/*
rollerball = noone;
rollerball_pos_x = x;
rollerball_pos_y = y + ((sprite_height * abs(image_yscale)) /2) - ((sprite_height * abs(image_yscale)) /6) - 5;
rollerball_radius = (sprite_width * abs(image_xscale))/2;
fix_ball = noone;
*/
fix_box = noone;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Player States
enum states{
    normal,
    sprint,
    hide,
    staircase,
    ladder,
    ledgegrab,
}

state = states.normal;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Get the inputs
get_input();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sprite Controller

var running = runButton &amp;&amp; !fatiqued;

if (grounded) 
{
    if(sliding &amp;&amp; (right ^^ left))
    {
        if (sprite_index != spr_slide)
        {  
            image_index = 0;
        }   
        sprite_index = spr_slide;
        image_speed = 3 * global.timeScale;
    }
    else if ((right ^^ left &amp;&amp; crouchButton))
    { 
        // same as before
        if (sprite_index != spr_crawl)
        { 
            image_index = 0;
        }
        sprite_index = spr_crawl;
        image_speed = 1 * global.timeScale;
    }
    else if (running &amp;&amp; (right ^^ left))//If running
    {
        /** if the sprite isn't the running sprite set index to zero so when 
          * it becomes the running sprite, it always starts on frame 0 */
        if (sprite_index != spr_running)
        {  
            image_index = 0;
        }   
        sprite_index = spr_running;
        image_speed = 3 * global.timeScale;
    }
    else if ((right ^^ left)) //If not running
    { 
        // same as before
        if (sprite_index != spr_walking) 
        { 
            image_index = 0;
        }
        sprite_index = spr_walking;
        image_speed = 4 * global.timeScale;
    }
    else if(crouchButton)
    {   
        sprite_index = spr_crouched_idle;
        image_speed = 1 * global.timeScale;
    }
    else 
    { 
        // if idle.
        sprite_index = spr_idle;
        image_speed = 1 * global.timeScale;
    }
}
else 
{ 
    // if not grounded...
    if (!grounded) 
    {
        if (sprite_index != spr_falling) 
        {
            image_index = 0;
        }
        sprite_index = spr_falling; // this has a script in "animation end" to avoid looping
        image_speed = 0.5 * global.timeScale;
    }
    if (grounded) 
    {
        sprite_index = spr_idle;
        image_speed  = 1 * global.timeScale;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Stamina Controller
/*if(runButton &amp;&amp; (right ^^ left))
{
    if(instance_exists(obj_guiManager))
    {
        if(obj_guiManager.mp &lt;= 1)
        {
            fatiqued = true;
        }
        else
        {
            obj_guiManager.mp -= 1;
        }
    }
}

if(obj_guiManager.mp &gt;= 5)
{
    fatiqued = false;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Main State Machine

if(place_meeting(x, y + 3, obj_collision_box))
{
    grounded = true;
}
else
{
    grounded = false;
}

//Player State Machine
switch (state)
{
    case states.normal:
    { 
        //Behavior
        scr_phy_motion();
        
        //Transitions
        
        if ((up || down) &amp;&amp; place_meeting(x, y + 1, obj_ladder_climb_mask)) 
        {
            state = states.ladder;
        }
        
        if(place_meeting(x, y + 1, obj_enter_stairs_mask) &amp;&amp; (up || down))
        {
            state = states.staircase;
        }
        
        if(place_meeting(x, y, obj_grabBlock)) 
        {
            state = states.ledgegrab; 
        }
         
    }break;
    case states.staircase: 
    {
        scr_player_stairs();
    }break;
    case states.ladder:
    {
        scr_player_ladder();
    }break;
    case states.ledgegrab:
    {
    
    }break;
    case states.hide:
    {
         
    }break;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Damage Events
if(place_meeting(x,y,obj_firetrap))
{
    if(instance_exists(obj_guiManager)) obj_guiManager.hp -= 1;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Door Code
if(place_meeting(x,y,obj_nextroom))
{
    door = instance_nearest(x, y, obj_nextroom);
    if(door != noone)
    {
        door.pressWprompt = true;
        
        if(keyboard_check_pressed(ord('W')))
        {
            lastRoom = room;
            lastRoomX = door.last_x;
            lastRoomY = door.last_y;
            start_x = door.new_x;
            start_y = door.new_y;
            door.pressWprompt = false;
            room_goto(door.next_room);
        }
    }
}
else
{
    if(door != noone &amp;&amp; instance_exists(door))
    {
        door.pressWprompt = false;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Inventory Controls

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Debug Stuff
if (keyboard_check(vk_enter)) 
{
    room_restart();
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_collision_box">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Do nothing (DO NOT DELETE)

//The Physics engine works off collision events like this one, but gamemaker
//tries to optimize your code by removing events with no actions, so this is
//just a dummy action so this event won't get removed.
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Blend Animations
if (sprite_index == spr_hide) 
{
    image_index = 14; // set frame speed to 0 at frame 19 (last frame)
    image_speed = 0; //Do not animate
}

if (sprite_index == spr_falling) 
{
    image_index = 24;
    image_speed = 0;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Reinitialize Player
sprite_index = spr_idle;
image_index = 0;
image_xscale = abs(image_xscale);
x = start_x;
y = start_y;
WalkingSpeed = WalkingSpeed * abs(image_xscale);
RunningSpeed = RunningSpeed * abs(image_xscale);
maxWalkingSpeed = maxWalkingSpeed * abs(image_xscale);
maxRunningSpeed = maxRunningSpeed * abs(image_xscale);
baseJumpSpeed = baseJumpSpeed * abs(image_xscale);
ladderSpeed = ladderSpeed * abs(image_xscale);
slopeScanValue = slopeScanValue * abs(image_xscale);
RunningSlopeScanValue = RunningSlopeScanValue * abs(image_xscale);
CrouchingSlopeScanValue = CrouchingSlopeScanValue * abs(image_xscale);
grounded = false;
/*
rollerball = noone;
rollerball_pos_x = x;
rollerball_pos_y = y + ((sprite_height * abs(image_yscale)) /2) - ((sprite_height * abs(image_yscale)) /6) - 5;
rollerball_radius = (sprite_width * abs(image_xscale))/2;
*/
physics_remove_fixture(id, fix_box)
physics_fixture_delete(fix_box);
player_physics();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw and Draw Debug
draw_self();
draw_set_color(c_white);
physics_draw_debug();
draw_text(x + 10, y - 10, grounded);
if(debug_mode){
    draw_text(x + 10, y - 10, grounded);
    switch (state){
        case states.normal: draw_text(x + 10, y - 10, "STATE = normal"); break;
        case states.staircase: draw_text(x + 10, y - 10, "STATE = staircase"); break;
        case states.ladder: draw_text(x + 10, y - 10, "STATE = ladder"); break;
        case states.ledgegrab: draw_text(x + 10, y - 10, "STATE = ledgegrab"); break;
        case states.hide: draw_text(x + 10, y - 10, "STATE = hide"); break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>1</PhysicsObjectShape>
  <PhysicsObjectDensity>1</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>1</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>1</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.5</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>-1</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
